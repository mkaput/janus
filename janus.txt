-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Simple scripting language written in Haskell, project for Fuctional Programming Course at AGH UST
--   
--   Please see README.md
@package janus
@version 0.1.0.0

module Language.Janus.AST
newtype Program
Program :: [Stmt] -> Program
newtype Ptr
Ptr :: Word -> Ptr
getAddress :: Ptr -> Word
data Ref
PtrRef :: Ptr -> Ref
IndexRef :: Ptr -> Val -> Ref
data Val
JUnit :: Val
JBool :: Bool -> Val
JInt :: Integer -> Val
JDouble :: Double -> Val
JChar :: Char -> Val
JStr :: String -> Val
JItem :: Item -> Val
showVal :: Val -> String
haskellTypeRep :: Val -> TypeRep
class ToVal a
toVal :: ToVal a => a -> Val
toVal :: ToVal a => a -> Val
toValI :: Integral a => a -> Val
toValF :: Float -> Val
toValD :: Double -> Val
class FromVal a where fromVal a = fromMaybe (error "Failed to convert Janus value to Haskell value") (tryFromVal a) tryFromVal = Just . fromVal
fromVal :: FromVal a => Val -> a
tryFromVal :: FromVal a => Val -> Maybe a
fromVal :: FromVal a => Val -> a
tryFromVal :: FromVal a => Val -> Maybe a
toLiteral :: ToVal a => a -> Expr
toLiteralI :: Integral a => a -> Expr
toLiteralF :: Float -> Expr
toLiteralD :: Double -> Expr
data Lvalue
Path :: String -> Lvalue
IndexLv :: String -> Expr -> Lvalue
data Expr
LiteralExpr :: Val -> Expr
BlockExpr :: Block -> Expr
ParenExpr :: Expr -> Expr
CallExpr :: Expr -> [Expr] -> Expr
PostfixIncExpr :: Lvalue -> Expr
PostfixDecExpr :: Lvalue -> Expr
NotExpr :: Expr -> Expr
BitNotExpr :: Expr -> Expr
PlusExpr :: Expr -> Expr
NegExpr :: Expr -> Expr
PrefixIncExpr :: Lvalue -> Expr
PrefixDecExpr :: Lvalue -> Expr
ExpExpr :: Expr -> Expr -> Expr
MulExpr :: Expr -> Expr -> Expr
DivExpr :: Expr -> Expr -> Expr
RemExpr :: Expr -> Expr -> Expr
AddExpr :: Expr -> Expr -> Expr
SubExpr :: Expr -> Expr -> Expr
LshExpr :: Expr -> Expr -> Expr
RshExpr :: Expr -> Expr -> Expr
BitAndExpr :: Expr -> Expr -> Expr
BitXorExpr :: Expr -> Expr -> Expr
BitOrExpr :: Expr -> Expr -> Expr
EqExpr :: Expr -> Expr -> Expr
NeqExpr :: Expr -> Expr -> Expr
LtExpr :: Expr -> Expr -> Expr
GtExpr :: Expr -> Expr -> Expr
LtEqExpr :: Expr -> Expr -> Expr
GtEqExpr :: Expr -> Expr -> Expr
AndExpr :: Expr -> Expr -> Expr
OrExpr :: Expr -> Expr -> Expr
IfExpr :: Expr -> Expr -> Maybe Expr -> Expr
WhileExpr :: Expr -> Expr -> Expr
LoopExpr :: Expr -> Expr
BreakExpr :: Expr
ContinueExpr :: Expr
ReturnExpr :: Expr -> Expr
LvalueExpr :: Lvalue -> Expr
newtype Block
Block :: [Stmt] -> Block
data Stmt
LetDecl :: String -> Expr -> Stmt
FnDecl :: String -> [String] -> Block -> Stmt
SubstStmt :: Lvalue -> Expr -> Stmt
ExprStmt :: Expr -> Stmt
data Item
Func :: String -> [String] -> Block -> Item
NativeFunc :: String -> [String] -> ([Val] -> InterpM Val) -> Item
instance GHC.Classes.Ord Language.Janus.AST.Ref
instance GHC.Classes.Eq Language.Janus.AST.Ref
instance GHC.Show.Show Language.Janus.AST.Ref
instance GHC.Classes.Ord Language.Janus.AST.Val
instance GHC.Classes.Eq Language.Janus.AST.Val
instance GHC.Show.Show Language.Janus.AST.Val
instance GHC.Classes.Eq Language.Janus.AST.Lvalue
instance GHC.Show.Show Language.Janus.AST.Lvalue
instance GHC.Classes.Eq Language.Janus.AST.Expr
instance GHC.Show.Show Language.Janus.AST.Expr
instance GHC.Classes.Eq Language.Janus.AST.Stmt
instance GHC.Show.Show Language.Janus.AST.Stmt
instance GHC.Classes.Eq Language.Janus.AST.Block
instance GHC.Show.Show Language.Janus.AST.Block
instance Data.Data.Data Language.Janus.AST.Ptr
instance GHC.Show.Show Language.Janus.AST.Ptr
instance GHC.Classes.Ord Language.Janus.AST.Ptr
instance GHC.Classes.Eq Language.Janus.AST.Ptr
instance GHC.Enum.Bounded Language.Janus.AST.Ptr
instance Data.Hashable.Class.Hashable Language.Janus.AST.Ptr
instance Language.Janus.AST.ToVal Language.Janus.AST.Val
instance Language.Janus.AST.ToVal ()
instance Language.Janus.AST.ToVal GHC.Types.Bool
instance Language.Janus.AST.ToVal GHC.Integer.Type.Integer
instance Language.Janus.AST.ToVal GHC.Types.Int
instance Language.Janus.AST.ToVal GHC.Types.Double
instance Language.Janus.AST.ToVal GHC.Types.Float
instance Language.Janus.AST.ToVal GHC.Types.Char
instance Language.Janus.AST.ToVal GHC.Base.String
instance Language.Janus.AST.ToVal Language.Janus.AST.Item
instance Language.Janus.AST.FromVal Language.Janus.AST.Val
instance Language.Janus.AST.FromVal ()
instance Language.Janus.AST.FromVal GHC.Types.Bool
instance Language.Janus.AST.FromVal GHC.Integer.Type.Integer
instance Language.Janus.AST.FromVal GHC.Types.Int
instance Language.Janus.AST.FromVal GHC.Types.Float
instance Language.Janus.AST.FromVal GHC.Types.Double
instance Language.Janus.AST.FromVal GHC.Types.Char
instance Language.Janus.AST.FromVal GHC.Base.String
instance Language.Janus.AST.FromVal Language.Janus.AST.Item
instance GHC.Show.Show Language.Janus.AST.Item
instance GHC.Classes.Eq Language.Janus.AST.Item
instance GHC.Classes.Ord Language.Janus.AST.Item

module Language.Janus.Interp

-- | Intepreter state.
data EvalState

-- | Interpreter error.
data EvalError

-- | Operator invocation type error
OpCallTypeError :: String -> [[TypeRep]] -> [TypeRep] -> EvalError

-- | <a>Callable</a> (e.g. function) call error
ItemCallError :: Item -> EvalError -> EvalError

-- | Tried to access out of bounds index
IndexOutOfBounds :: EvalError

-- | Internal interpreter error - a bug
InternalError :: String -> EvalError

-- | Tried to access unallocated memory cell
InvalidPointer :: Ptr -> EvalError

-- | Expected boolean value (e.g. in condition)
ExpectedBool :: Val -> EvalError

-- | Expected reference (e.g. in call operator)
ExpectedRef :: EvalError

-- | Given value is not callable
NotCallable :: Val -> EvalError

-- | Cannot allocate more memory cells
OutOfMemory :: EvalError

-- | Cannot resolve requested symbol
UndefinedSymbol :: String -> EvalError

-- | In-code exception
CustomError :: String -> EvalError

-- | Interpreter monad.
type InterpM = StateT EvalState (ExceptT EvalError IO)

-- | Run action inside clean <a>InterpM</a>.
runInterpM :: InterpM a -> IO (Either EvalError a)

-- | Evaluate <a>Evaluable</a> entity inside clean <a>InterpM</a>.
run :: Evaluable a => a -> IO (Either EvalError Val)

-- | Dereference a <a>Ref</a> - get <a>Val</a> given reference points to.
deref :: Ref -> InterpM Val

-- | Alter value given <a>Ref</a> points to.
refset :: Ref -> Val -> InterpM ()

-- | Push new scope.
pushScope :: InterpM ()

-- | Pop top stack frame.
popFrame :: InterpM ()

-- | Check whether given pointer points to unallocated memory cell.
memIsFree :: Ptr -> InterpM Bool

-- | Get value of given memory cell.
memGetVal :: Ptr -> InterpM Val

-- | Get reference count of given memory cell.
memGetRc :: Ptr -> InterpM Word

-- | Allocate value in interpreter memory. Returns new memory cell's
--   address.
malloc :: Val -> InterpM Ptr

-- | Set value at given address.
memset :: Ptr -> Val -> InterpM ()

-- | Increment reference count of memory cell at given address.
rcIncr :: Ptr -> InterpM ()

-- | Decrement reference count of memory cell at given address. If the RC
--   will reach 0, the cell will be deallocated.
rcDecr :: Ptr -> InterpM ()

-- | Lookup variable in all available scopes.
lookupVar :: String -> InterpM Ptr

-- | Create new, or change existing, variable binding. If the variable has
--   been already exising, its old value's reference count will be
--   decremented.
putVar :: String -> Ptr -> InterpM ()

-- | <pre>
--   evalVal name = lookupVar name &gt;&gt;= memGetVal
--   </pre>
evalVal :: String -> InterpM Val

-- | Enumerate all visible symbols.
allVars :: InterpM [String]

-- | The Evaluable class denotes enitity which can be evaluated to
--   <a>Val</a>.
class Evaluable a
eval :: Evaluable a => a -> InterpM Val

-- | The RefEvaluable class denotes enitity which can be evaluated to
--   <a>Ref</a>
class RefEvaluable a where evalRef a = tryEvalRef a `unwrapM'` ExpectedRef tryEvalRef a = Just `fmap` evalRef a

-- | Throws <a>ExpectedRef</a> if <a>tryEvalRef</a> returns <a>Nothing</a>.
evalRef :: RefEvaluable a => a -> InterpM Ref
tryEvalRef :: RefEvaluable a => a -> InterpM (Maybe Ref)

-- | The Callable class denotes enitity which can be called, such as
--   functions.
class Callable a
call :: Callable a => a -> [Val] -> InterpM Val
valGetIdx :: Val -> Val -> InterpM Val
valSetIdx :: Val -> Val -> Val -> InterpM Val
instance GHC.Show.Show Language.Janus.Interp.MemCell
instance GHC.Classes.Eq Language.Janus.Interp.MemCell
instance GHC.Classes.Ord Language.Janus.Interp.EvalError
instance GHC.Classes.Eq Language.Janus.Interp.EvalError
instance GHC.Show.Show Language.Janus.Interp.EvalError
instance Language.Janus.Interp.Evaluable Language.Janus.AST.Val
instance Language.Janus.Interp.Evaluable Language.Janus.Interp.EvalError
instance Language.Janus.Interp.Evaluable Language.Janus.AST.Program
instance Language.Janus.Interp.Evaluable Language.Janus.AST.Lvalue
instance Language.Janus.Interp.Evaluable Language.Janus.AST.Expr
instance Language.Janus.Interp.Evaluable Language.Janus.AST.Block
instance Language.Janus.Interp.Evaluable Language.Janus.AST.Stmt
instance Language.Janus.Interp.RefEvaluable Language.Janus.AST.Ptr
instance Language.Janus.Interp.RefEvaluable Language.Janus.AST.Ref
instance Language.Janus.Interp.RefEvaluable Language.Janus.AST.Lvalue
instance Language.Janus.Interp.RefEvaluable Language.Janus.AST.Expr
instance Language.Janus.Interp.Callable Language.Janus.AST.Val
instance Language.Janus.Interp.Callable Language.Janus.AST.Item

module Language.Janus.Parser

-- | Parse whole Janus program source code.
parseProgram :: String -> String -> Either ParseError Program

-- | Parse single statement
parseStatement :: String -> Either ParseError Stmt

-- | Parse single expression
parseExpression :: String -> Either ParseError Expr

-- | Parse single literal
parseLiteral :: String -> Either ParseError Val

module Language.Janus.Stdlib

-- | Import standard library items into current interpreter.
importStdlib :: InterpM ()

-- | <pre>
--   retVal = return . <a>toVal</a>
--   </pre>
retVal :: ToVal a => a -> InterpM Val

-- | Throw <a>CustomError</a> with given message.
throwEx :: String -> InterpM a

-- | Allocate value and bind it to variable.
putNativeVar :: ToVal a => String -> a -> InterpM ()

-- | Declare native function.
putNativeFunc :: String -> [String] -> ([Val] -> InterpM Val) -> InterpM ()
